<!DOCTYPE html>
<html lang="th">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Stickman Horror: The Rooms</title>
    <script>
        // ‡∏£‡∏∞‡∏ö‡∏ö‡πÅ‡∏à‡πâ‡∏á‡πÄ‡∏ï‡∏∑‡∏≠‡∏ô Error (‡∏ñ‡πâ‡∏≤‡πÄ‡∏Å‡∏°‡∏û‡∏±‡∏á‡∏à‡∏∞‡πÄ‡∏î‡πâ‡∏á‡∏ö‡∏≠‡∏Å‡∏ó‡∏±‡∏ô‡∏ó‡∏µ)
        window.onerror = function(msg, url, line) {
            alert("‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î!\n" + msg + "\n‡∏ö‡∏£‡∏£‡∏ó‡∏±‡∏î‡∏ó‡∏µ‡πà: " + line);
            return false;
        };
    </script>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #050505;
            overflow: hidden;
            /* ‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç: ‡∏¢‡πâ‡∏≤‡∏¢ touch-action ‡πÑ‡∏õ‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£‡πÄ‡∏â‡∏û‡∏≤‡∏∞‡∏™‡πà‡∏ß‡∏ô */
            font-family: 'Sarabun', sans-serif;
            user-select: none;
            -webkit-user-select: none;
        }
        canvas {
            display: block;
            touch-action: none; /* ‡∏´‡πâ‡∏≤‡∏°‡πÄ‡∏•‡∏∑‡πà‡∏≠‡∏ô‡∏à‡∏≠‡πÄ‡∏â‡∏û‡∏≤‡∏∞‡∏ï‡∏≠‡∏ô‡πÄ‡∏•‡πà‡∏ô‡πÄ‡∏Å‡∏° */
        }
        
        /* --- UI Layers --- */
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: none;
            flex-direction: column;
            justify-content: space-between;
            z-index: 5;
        }
        .hud {
            padding: 20px;
            color: #eee;
            text-shadow: 2px 2px 0 #000;
            font-size: 20px;
            display: flex;
            justify-content: space-between;
            background: linear-gradient(to bottom, rgba(0,0,0,0.8), transparent);
        }
        #key-counter {
            color: #ffd700;
            font-weight: bold;
        }
        #status-msg {
            color: #ff4444;
            font-weight: bold;
            text-align: right;
        }
        
        /* --- Screens (Menu & Game Over) --- */
        .screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: white;
            z-index: 20;
            pointer-events: auto;
            touch-action: manipulation; /* ‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç: ‡πÉ‡∏´‡πâ‡∏õ‡∏∏‡πà‡∏°‡∏Å‡∏î‡∏ï‡∏¥‡∏î‡∏á‡πà‡∏≤‡∏¢‡∏ö‡∏ô‡∏°‡∏∑‡∏≠‡∏ñ‡∏∑‡∏≠ */
        }
        
        #main-menu { background: #000; }
        #game-over-screen { display: none; }

        h1 { margin-bottom: 10px; font-size: 40px; text-align: center; color: #d32f2f; text-shadow: 0 0 10px #ff0000; }
        p { margin-bottom: 30px; font-size: 18px; color: #aaa; text-align: center; }
        
        .btn {
            background: #222;
            border: 1px solid #444;
            color: white;
            padding: 20px 50px; /* ‡∏õ‡∏∏‡πà‡∏°‡πÉ‡∏´‡∏ç‡πà‡∏Ç‡∏∂‡πâ‡∏ô */
            font-size: 24px;
            cursor: pointer;
            border-radius: 10px;
            transition: all 0.2s;
            font-family: 'Sarabun', sans-serif;
            margin-top: 15px;
            /* ‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç: ‡∏ö‡∏±‡∏á‡∏Ñ‡∏±‡∏ö‡πÉ‡∏´‡πâ‡∏õ‡∏∏‡πà‡∏°‡∏£‡∏±‡∏ö‡∏™‡∏±‡∏°‡∏ú‡∏±‡∏™‡πÅ‡∏ô‡πà‡∏ô‡∏≠‡∏ô */
            touch-action: manipulation;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
        }
        .btn:hover { background: #333; border-color: #666; }
        .btn:active { transform: scale(0.95); background: #444; }
        
        .btn-start { border-left: 5px solid #4caf50; }
        .btn-retry { border-left: 5px solid #ff9800; }

        #controls-hint {
            position: absolute;
            bottom: 30px;
            width: 100%;
            text-align: center;
            color: rgba(255,255,255,0.4);
            font-size: 14px;
            pointer-events: none;
        }
    </style>
</head>
<body>

    <!-- Main Menu -->
    <div id="main-menu" class="screen">
        <h1>STICKMAN HORROR<br><span style="font-size:24px; color:#aaa;">THE ROOMS</span></h1>
        <p>‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤‡∏Å‡∏∏‡∏ç‡πÅ‡∏à 5 ‡∏î‡∏≠‡∏Å ‡πÅ‡∏•‡πâ‡∏ß‡∏´‡∏ô‡∏µ‡πÑ‡∏õ‡∏ã‡∏∞</p>
        <!-- ‡πÄ‡∏û‡∏¥‡πà‡∏° ontouchstart ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡∏ä‡∏±‡∏ß‡∏£‡πå -->
        <button class="btn btn-start" onclick="startGame()">‡πÄ‡∏£‡∏¥‡πà‡∏°‡πÄ‡∏Å‡∏°</button>
    </div>

    <!-- UI Layer -->
    <div id="ui-layer">
        <div class="hud">
            <span id="key-counter">üîë 0/5</span>
            <span id="status-msg">‡∏´‡∏≤‡∏ó‡∏≤‡∏á‡∏≠‡∏≠‡∏Å...</span>
        </div>
        <div id="controls-hint">‡πÅ‡∏ï‡∏∞‡∏Ñ‡πâ‡∏≤‡∏á‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÄ‡∏î‡∏¥‡∏ô / ‡∏•‡∏≤‡∏Å‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏ß‡∏¥‡πà‡∏á</div>
    </div>

    <!-- Game Over Screen -->
    <div id="game-over-screen" class="screen">
        <h1 id="go-title">Game Over</h1>
        <p id="go-desc">‡πÇ‡∏î‡∏ô‡∏à‡∏±‡∏ö‡πÑ‡∏î‡πâ‡∏ã‡∏∞‡πÅ‡∏•‡πâ‡∏ß...</p>
        <button class="btn btn-retry" onclick="startGame()">‡πÄ‡∏•‡πà‡∏ô‡πÉ‡∏´‡∏°‡πà‡∏≠‡∏µ‡∏Å‡∏Ñ‡∏£‡∏±‡πâ‡∏á</button>
        <button class="btn" onclick="showMainMenu()" style="margin-top: 10px; font-size: 18px; padding: 15px 30px;">‡∏Å‡∏•‡∏±‡∏ö‡πÄ‡∏°‡∏ô‡∏π‡∏´‡∏•‡∏±‡∏Å</button>
    </div>

    <canvas id="gameCanvas"></canvas>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        // DOM Elements
        const mainMenu = document.getElementById('main-menu');
        const uiLayer = document.getElementById('ui-layer');
        const goScreen = document.getElementById('game-over-screen');
        const uiKeys = document.getElementById('key-counter');
        const uiStatus = document.getElementById('status-msg');
        const goTitle = document.getElementById('go-title');
        const goDesc = document.getElementById('go-desc');

        // Game Config
        const TILE_SIZE = 50;
        const MAP_WIDTH = 50;
        const MAP_HEIGHT = 50;
        
        // Game State
        let map = [];
        let rooms = [];
        let player = { x: 0, y: 0, radius: 12, speed: 5, angle: 0, moving: false };
        let ghost = { x: 0, y: 0, radius: 18, speed: 2.2 };
        let camera = { x: 0, y: 0 };
        
        let keys = [];
        let totalKeys = 5;
        let keysCollected = 0;
        let exitDoor = { x: 0, y: 0, open: false };
        
        let isGameRunning = false;
        let gameTime = 0;

        // Input State
        let touchData = { active: false, startX: 0, startY: 0, currX: 0, currY: 0 };

        // Resize Canvas
        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            if(!isGameRunning) {
                ctx.fillStyle = '#000';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            }
        }
        window.addEventListener('resize', resize);
        resize();

        // --- Core Functions ---

        function showMainMenu() {
            isGameRunning = false;
            goScreen.style.display = 'none';
            uiLayer.style.display = 'none';
            mainMenu.style.display = 'flex';
        }

        function startGame() {
            try {
                // UI Toggle
                mainMenu.style.display = 'none';
                goScreen.style.display = 'none';
                uiLayer.style.display = 'flex';
                
                // Reset State
                isGameRunning = true;
                keysCollected = 0;
                exitDoor.open = false;
                gameTime = 0;
                touchData.active = false;
                
                // Reset HUD
                updateHUD();
                uiStatus.textContent = "‡∏´‡∏≤‡∏ó‡∏≤‡∏á‡∏≠‡∏≠‡∏Å...";
                uiStatus.style.color = "#ff4444";
                
                // Start Logic
                generateMap();
                loop();
            } catch (e) {
                alert("Start Error: " + e.message);
            }
        }

        function generateMap() {
            map = [];
            rooms = [];
            
            // 1. Create Walls
            for (let y = 0; y < MAP_HEIGHT; y++) {
                let row = [];
                for (let x = 0; x < MAP_WIDTH; x++) row.push(1);
                map.push(row);
            }

            // 2. Create Rooms
            const MAX_ROOMS = 25;
            for (let i = 0; i < MAX_ROOMS; i++) {
                const w = Math.floor(Math.random() * 6) + 5; // 5-10
                const h = Math.floor(Math.random() * 6) + 5;
                const x = Math.floor(Math.random() * (MAP_WIDTH - w - 2)) + 1;
                const y = Math.floor(Math.random() * (MAP_HEIGHT - h - 2)) + 1;

                const newRoom = { x, y, w, h, cx: x + Math.floor(w/2), cy: y + Math.floor(h/2) };

                let failed = false;
                for (let other of rooms) {
                    if (newRoom.x <= other.x + other.w && newRoom.x + newRoom.w >= other.x &&
                        newRoom.y <= other.y + other.h && newRoom.y + newRoom.h >= other.y) {
                        failed = true; break;
                    }
                }

                if (!failed) {
                    createRoom(newRoom);
                    if (rooms.length > 0) {
                        const prev = rooms[rooms.length - 1];
                        createCorridor(prev.cx, prev.cy, newRoom.cx, newRoom.cy);
                    }
                    rooms.push(newRoom);
                }
            }

            // 3. Place Objects
            if(rooms.length > 0) {
                player.x = rooms[0].cx * TILE_SIZE;
                player.y = rooms[0].cy * TILE_SIZE;
                
                const lastRoom = rooms[rooms.length - 1];
                ghost.x = lastRoom.cx * TILE_SIZE;
                ghost.y = lastRoom.cy * TILE_SIZE;
            }

            keys = [];
            if(rooms.length > 1) {
                let avail = rooms.slice(1);
                avail.sort(() => Math.random() - 0.5);

                for (let i = 0; i < totalKeys; i++) {
                    if (i < avail.length) {
                        keys.push({ x: avail[i].cx * TILE_SIZE, y: avail[i].cy * TILE_SIZE, collected: false });
                    }
                }
                
                let exitR = avail[avail.length - 1]; 
                exitDoor = { x: exitR.cx * TILE_SIZE, y: exitR.cy * TILE_SIZE, open: false };
            }
        }

        function createRoom(r) {
            for (let y = r.y; y < r.y + r.h; y++) {
                for (let x = r.x; x < r.x + r.w; x++) map[y][x] = 0;
            }
        }

        function createCorridor(x1, y1, x2, y2) {
            let x = x1, y = y1;
            while (x !== x2) { map[y][x] = 0; map[y][x+1] = 0; x += (x < x2) ? 1 : -1; }
            while (y !== y2) { map[y][x] = 0; map[y][x+1] = 0; y += (y < y2) ? 1 : -1; }
        }

        // --- Controls ---
        function handleStart(x, y) {
            touchData.active = true;
            touchData.startX = x; touchData.startY = y;
            touchData.currX = x; touchData.currY = y;
        }
        function handleMove(x, y) {
            if (!touchData.active) return;
            touchData.currX = x; touchData.currY = y;
            const dx = x - touchData.startX;
            const dy = y - touchData.startY;
            if (Math.hypot(dx, dy) > 10) {
                player.moving = true;
                player.angle = Math.atan2(dy, dx);
            }
        }
        function handleEnd() { touchData.active = false; player.moving = false; }

        window.addEventListener('touchstart', e => { 
            // Only prevent default on canvas to allow button clicks
            if(e.target === canvas) e.preventDefault();
            handleStart(e.touches[0].clientX, e.touches[0].clientY); 
        }, {passive:false});
        
        window.addEventListener('touchmove', e => { 
            if(e.target === canvas) e.preventDefault();
            handleMove(e.touches[0].clientX, e.touches[0].clientY); 
        }, {passive:false});
        
        window.addEventListener('touchend', handleEnd);
        
        // Mouse Fallback
        window.addEventListener('mousedown', e => handleStart(e.clientX, e.clientY));
        window.addEventListener('mousemove', e => handleMove(e.clientX, e.clientY));
        window.addEventListener('mouseup', handleEnd);

        // --- Game Logic ---
        function checkWall(x, y) {
            let tx = Math.floor(x / TILE_SIZE);
            let ty = Math.floor(y / TILE_SIZE);
            if (tx < 0 || tx >= MAP_WIDTH || ty < 0 || ty >= MAP_HEIGHT) return true;
            return map[ty][tx] === 1;
        }

        function resolveCollision(newX, newY) {
            const p = player.radius * 0.8;
            if (!checkWall(newX-p, player.y-p) && !checkWall(newX+p, player.y-p) &&
                !checkWall(newX-p, player.y+p) && !checkWall(newX+p, player.y+p)) player.x = newX;
            
            if (!checkWall(player.x-p, newY-p) && !checkWall(player.x+p, newY-p) &&
                !checkWall(player.x-p, newY+p) && !checkWall(player.x+p, newY+p)) player.y = newY;
        }

        function update() {
            gameTime++;

            // Player
            if (player.moving) {
                let dx = Math.cos(player.angle) * player.speed;
                let dy = Math.sin(player.angle) * player.speed;
                resolveCollision(player.x + dx, player.y + dy);
            }

            // Ghost
            let gx = player.x - ghost.x;
            let gy = player.y - ghost.y;
            let dist = Math.hypot(gx, gy);
            
            if (dist > 0) {
                let speed = ghost.speed;
                if (dist > 600) speed *= 1.5;
                ghost.x += (gx / dist) * speed;
                ghost.y += (gy / dist) * speed;
            }

            if (dist < player.radius + ghost.radius) gameOver(false);

            // Keys
            keys.forEach(k => {
                if (!k.collected && Math.hypot(player.x - k.x, player.y - k.y) < 30) {
                    k.collected = true;
                    keysCollected++;
                    updateHUD();
                }
            });

            // Exit
            if (keysCollected >= totalKeys && Math.hypot(player.x - exitDoor.x, player.y - exitDoor.y) < 40) {
                gameOver(true);
            }

            // Camera
            camera.x = Math.max(0, Math.min(player.x - canvas.width/2, MAP_WIDTH * TILE_SIZE - canvas.width));
            camera.y = Math.max(0, Math.min(player.y - canvas.height/2, MAP_HEIGHT * TILE_SIZE - canvas.height));
        }

        function updateHUD() {
            uiKeys.textContent = `üîë ${keysCollected}/${totalKeys}`;
            if (keysCollected >= totalKeys) {
                uiStatus.textContent = "‡∏õ‡∏£‡∏∞‡∏ï‡∏π‡πÄ‡∏õ‡∏¥‡∏î‡πÅ‡∏•‡πâ‡∏ß! ‡∏´‡∏≤‡∏ó‡∏≤‡∏á‡∏≠‡∏≠‡∏Å!";
                uiStatus.style.color = "#4eff4e";
                exitDoor.open = true;
            }
        }

        function gameOver(win) {
            isGameRunning = false;
            uiLayer.style.display = 'none';
            goScreen.style.display = 'flex';
            if (win) {
                goTitle.textContent = "‡∏´‡∏ô‡∏µ‡∏£‡∏≠‡∏î‡πÅ‡∏•‡πâ‡∏ß!";
                goTitle.style.color = "#4eff4e";
                goDesc.textContent = "‡∏Ñ‡∏∏‡∏ì‡∏´‡∏≤‡∏ó‡∏≤‡∏á‡∏≠‡∏≠‡∏Å‡πÄ‡∏à‡∏≠ ‡∏¢‡∏≠‡∏î‡πÄ‡∏¢‡∏µ‡πà‡∏¢‡∏°‡∏°‡∏≤‡∏Å!";
            } else {
                goTitle.textContent = "Game Over";
                goTitle.style.color = "#ff4444";
                goDesc.textContent = "‡∏ú‡∏µ‡∏à‡∏±‡∏ö‡∏Ñ‡∏∏‡∏ì‡∏Å‡∏¥‡∏ô‡∏ï‡∏±‡∏ö...";
            }
        }

        function loop() {
            if (isGameRunning) {
                update();
                draw();
                requestAnimationFrame(loop);
            }
        }

        function draw() {
            if(!isGameRunning) return;
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.save();
            ctx.translate(-camera.x, -camera.y);

            // Draw Map (Optimized)
            let sc = Math.floor(camera.x / TILE_SIZE), ec = sc + Math.ceil(canvas.width/TILE_SIZE) + 1;
            let sr = Math.floor(camera.y / TILE_SIZE), er = sr + Math.ceil(canvas.height/TILE_SIZE) + 1;

            for (let y = sr; y <= er; y++) {
                for (let x = sc; x <= ec; x++) {
                    if (y >= 0 && y < MAP_HEIGHT && x >= 0 && x < MAP_WIDTH) {
                        ctx.fillStyle = (map[y][x] === 1) ? '#1a1a1a' : '#2d2d2d';
                        ctx.fillRect(x*TILE_SIZE, y*TILE_SIZE, TILE_SIZE, TILE_SIZE);
                        if(map[y][x] === 1) { ctx.strokeStyle = '#333'; ctx.strokeRect(x*TILE_SIZE, y*TILE_SIZE, TILE_SIZE, TILE_SIZE); }
                    }
                }
            }

            // Keys
            keys.forEach(k => {
                if (!k.collected) {
                    ctx.save();
                    ctx.translate(k.x, k.y + Math.sin(gameTime*0.1)*5);
                    ctx.fillStyle = '#ffd700';
                    ctx.shadowColor = '#ffd700'; ctx.shadowBlur = 10;
                    ctx.beginPath(); ctx.arc(0, -5, 8, 0, Math.PI*2); ctx.fill();
                    ctx.fillRect(-2, -5, 4, 20); ctx.fillRect(0, 8, 6, 3);
                    ctx.restore();
                }
            });

            // Exit
            ctx.save();
            ctx.translate(exitDoor.x, exitDoor.y);
            ctx.fillStyle = exitDoor.open ? '#00ff00' : '#555';
            ctx.fillRect(-20, -20, 40, 40);
            ctx.fillStyle = '#fff'; ctx.font = 'bold 12px sans-serif'; ctx.textAlign = 'center'; 
            ctx.fillText(exitDoor.open?"EXIT":"LOCKED",0,0);
            if(exitDoor.open) { ctx.strokeStyle='#fff'; ctx.lineWidth=2; ctx.strokeRect(-22,-22,44,44); }
            ctx.restore();

            // Player
            ctx.save(); ctx.translate(player.x, player.y);
            ctx.strokeStyle = 'white'; ctx.lineWidth = 3; ctx.lineCap = 'round';
            ctx.beginPath(); ctx.arc(0, -15, 10, 0, Math.PI*2); ctx.stroke();
            ctx.beginPath(); ctx.moveTo(0, -5); ctx.lineTo(0, 15); ctx.stroke();
            let leg = player.moving ? Math.sin(gameTime*0.3)*8 : 0;
            ctx.beginPath(); ctx.moveTo(0, 15); ctx.lineTo(-8+leg, 35); ctx.stroke();
            ctx.beginPath(); ctx.moveTo(0, 15); ctx.lineTo(8-leg, 35); ctx.stroke();
            ctx.beginPath(); ctx.moveTo(0, -2); ctx.lineTo(Math.cos(player.angle)*15, Math.sin(player.angle)*15); ctx.stroke();
            // Flashlight
            ctx.rotate(player.angle); ctx.fillStyle = 'rgba(255, 255, 200, 0.2)';
            ctx.beginPath(); ctx.moveTo(0, 0); ctx.arc(0, 0, 150, -0.3, 0.3); ctx.fill();
            ctx.restore();

            // Ghost
            ctx.save(); ctx.translate(ghost.x, ghost.y);
            ctx.fillStyle = 'rgba(255, 50, 50, 0.8)'; ctx.shadowColor = 'red'; ctx.shadowBlur = 20;
            ctx.beginPath(); ctx.arc(0, -10, 15, Math.PI, 0); ctx.lineTo(15, 20);
            ctx.quadraticCurveTo(7, 10, 0, 20); ctx.quadraticCurveTo(-7, 10, -15, 20); ctx.fill();
            ctx.fillStyle = '#fff'; ctx.beginPath(); ctx.arc(-6, -10, 4, 0, Math.PI*2); ctx.arc(6, -10, 4, 0, Math.PI*2); ctx.fill();
            ctx.restore();

            ctx.restore();

            // Darkness Overlay
            const g = ctx.createRadialGradient(canvas.width/2, canvas.height/2, 50, canvas.width/2, canvas.height/2, canvas.height);
            let d = Math.max(0, 1 - (Math.hypot(player.x-ghost.x, player.y-ghost.y)/400));
            g.addColorStop(0, 'rgba(0,0,0,0)'); g.addColorStop(0.3, 'rgba(0,0,0,0.1)');
            g.addColorStop(1, `rgba(${50+d*200}, 0, 0, ${0.6+d*0.3})`);
            ctx.fillStyle = g; ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Joystick Visual
            if (touchData.active) {
                ctx.beginPath(); ctx.arc(touchData.startX, touchData.startY, 40, 0, Math.PI*2);
                ctx.strokeStyle = 'rgba(255,255,255,0.3)'; ctx.lineWidth = 3; ctx.stroke();
                ctx.beginPath(); ctx.arc(touchData.currX, touchData.currY, 20, 0, Math.PI*2);
                ctx.fillStyle = 'rgba(255,255,255,0.5)'; ctx.fill();
            }
        }
    </script>
</body>
</html>
